<!doctype html><html lang=en dir=auto data-theme=dark><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>From O(N) to O(1): Building a Java Search Engine from Scratch | Muhammad Qasim</title><meta name=keywords content="Java,Algorithms,System Design"><meta name=description content="How I built a Positional Inverted Index and TF-IDF ranker without using Lucene or Elasticsearch."><meta name=author content="Muhammad Qasim"><link rel=canonical href=https://kas-sim.github.io/posts/building-search-engine-from-scratch/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://kas-sim.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://kas-sim.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://kas-sim.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://kas-sim.github.io/apple-touch-icon.png><link rel=mask-icon href=https://kas-sim.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://kas-sim.github.io/posts/building-search-engine-from-scratch/><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><script>localStorage.getItem("pref-theme")==="light"&&(document.querySelector("html").dataset.theme="light")</script><meta property="og:url" content="https://kas-sim.github.io/posts/building-search-engine-from-scratch/"><meta property="og:site_name" content="Muhammad Qasim"><meta property="og:title" content="From O(N) to O(1): Building a Java Search Engine from Scratch"><meta property="og:description" content="How I built a Positional Inverted Index and TF-IDF ranker without using Lucene or Elasticsearch."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-11-01T00:00:00+00:00"><meta property="article:modified_time" content="2024-11-01T00:00:00+00:00"><meta property="article:tag" content="Java"><meta property="article:tag" content="Algorithms"><meta property="article:tag" content="System Design"><meta name=twitter:card content="summary"><meta name=twitter:title content="From O(N) to O(1): Building a Java Search Engine from Scratch"><meta name=twitter:description content="How I built a Positional Inverted Index and TF-IDF ranker without using Lucene or Elasticsearch."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://kas-sim.github.io/posts/"},{"@type":"ListItem","position":2,"name":"From O(N) to O(1): Building a Java Search Engine from Scratch","item":"https://kas-sim.github.io/posts/building-search-engine-from-scratch/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"From O(N) to O(1): Building a Java Search Engine from Scratch","name":"From O(N) to O(1): Building a Java Search Engine from Scratch","description":"How I built a Positional Inverted Index and TF-IDF ranker without using Lucene or Elasticsearch.","keywords":["Java","Algorithms","System Design"],"articleBody":"Note: This is an architectural deep-dive into the core indexing engine of DevShelf.\nThe Problem with Linear Search When I started building DevShelf, the naive approach was simple: load all books into a List and loop through them checking if (book.contains(query)).\nFor 10 books, this is fine. For 1,000 books, it‚Äôs slow. For 1,000,000 books, the system crashes. This is an $O(N \\cdot M)$ operation, where $N$ is books and $M$ is words. We needed $O(1)$.\nThe Solution: Offline Inverted Indexing To solve this, I implemented an Offline Indexer (IndexerMain) that pre-processes the data‚Ä¶\nWhat Problem Does the ‚ÄúSecret Catalog‚Äù Solve? Imagine DevShelf has hundreds or even thousands of books. If you search for ‚ÄúPython machine learning,‚Äù DevShelf can‚Äôt just scan every single book‚Äôs title, author, and description in real-time. That would be too slow and would make your search results appear with a frustrating delay.\nThe problem Offline Search Indexing solves is this: How can DevShelf provide instant search results for thousands of books without having to read them all every time you type a query?\nOur central use case: When you start DevShelf, it should be ready to give you instant, relevant search results for any query, big or small.\nTo achieve this, DevShelf does a lot of heavy lifting once, in advance. It builds special ‚Äúlookup tables‚Äù that are super quick to check, like a meticulously organized index for the entire library.\nKey Concepts of Offline Search Indexing Offline Search Indexing involves a special process that creates these fast lookup tables:\nIt‚Äôs an Offline Process: This means it‚Äôs a separate program you run once, or whenever new books are added. It doesn‚Äôt run every time DevShelf starts. Think of it as updating the library‚Äôs main card catalog overnight, so it‚Äôs ready for customers in the morning.\nBuilding the Inverted Index: This is like the index at the back of a textbook, but for our entire library!\nYou look up a word (like ‚Äúpython‚Äù). It quickly tells you all the books that contain that word, and even where it appears. It ‚Äúinverts‚Äù the usual way of thinking (book -\u003e words) to (word -\u003e books). Calculating TF-IDF Scores: This helps DevShelf understand how important a word is to a specific book, compared to its importance across all books.\nTF (Term Frequency): How many times a word appears in one book. More occurrences mean more importance to that book. IDF (Inverse Document Frequency): How rare a word is across all books. A rare word (like ‚Äúquantum entanglement‚Äù) is more significant than a common word (like ‚Äúprogramming‚Äù). TF-IDF = TF * IDF: This combined score tells us the overall ‚Äúimportance‚Äù of a word in a specific book, helping DevShelf rank results more intelligently. These pre-computed data (the inverted index and all the TF-IDF scores) are then saved into a special file.\nHow to Build the Search Index You use a special program called IndexerMain (short for ‚ÄúIndexer Main Program‚Äù) to do all this work. You usually run it directly from your computer‚Äôs terminal, not through DevShelf‚Äôs normal interface. It‚Äôs like a dedicated librarian assistant who spends hours organizing the catalog.\nsrc/main/java/core/IndexerMain.java (Simplified)\npackage core; import domain.Book; import domain.SearchIndexData; import features.search.IndexBuilder; import storage.BookLoader; import utils.TextProcessor; import utils.TfIdfCalculator; import com.fasterxml.jackson.databind.ObjectMapper; // Tool to save to JSON import java.io.File; import java.util.List; import java.util.Set; public class IndexerMain { // This is where our super-fast index will be saved private static final String INDEX_OUTPUT_PATH = \"src/main/resources/data/index_data.json\"; public static void main(String[] args) { System.out.println(\"--- Starting Offline Indexer ---\"); try { // 1. Prepare our tools Set\u003cString\u003e stopWords = StopWordLoader.loadStopWords(\"/data/stopword.txt\"); TextProcessor textProcessor = new TextProcessor(stopWords); BookLoader bookLoader = new BookLoader(\"/data/book.json\"); IndexBuilder indexer = new IndexBuilder(textProcessor); TfIdfCalculator tfIdfCalculator = new TfIdfCalculator(); // 2. Load all the books (from Chapter 2) List\u003cBook\u003e allBooks = bookLoader.loadBooks(); System.out.println(\"Loading and indexing \" + allBooks.size() + \" books...\"); // 3. Build the Inverted Index for each book for(Book book : allBooks) { indexer.indexDocument(book); // This analyzes each book's text } System.out.println(\"Indexing Complete. Found \" + indexer.getInvertedIndex().size() + \" unique terms.\"); // 4. Calculate TF-IDF scores based on the inverted index tfIdfCalculator.calculateIdf(indexer.getInvertedIndex(), allBooks.size()); tfIdfCalculator.calculateTfIdf(indexer.getInvertedIndex()); System.out.println(\"TF-IDF calculation complete.\"); // 5. Gather all the index data into one object SearchIndexData indexData = new SearchIndexData( indexer.getInvertedIndex(), tfIdfCalculator.getTfIdfVectors(), tfIdfCalculator.getIdfScores() ); // 6. Save this data to a file (index_data.json) ObjectMapper mapper = new ObjectMapper(); // Our JSON saving tool mapper.writeValue(new File(INDEX_OUTPUT_PATH), indexData); // Write the data System.out.println(\"--- ‚úÖ Indexer Finished Successfully! --- \"); } catch (Exception e) { System.err.println(\" --- ‚ùå Indexer failed with an error. --- \"); e.printStackTrace(); } } } When you run IndexerMain, it does the following:\nGets Ready: It loads the Text Preprocessing tools and the Book (Domain Model) loader. Loads Books: It reads all the books from book.json. Indexes Books: For each book, it uses the IndexBuilder to create entries in the inverted index. Calculates Scores: It then uses the TfIdfCalculator to figure out the importance of each word in each book. Saves Everything: All this organized data is bundled into a SearchIndexData object and saved as a file named index_data.json. After IndexerMain finishes, the index_data.json file is created. This file holds all the ‚Äúsecret catalog‚Äù information, ready for DevShelf to use when it starts.\nWhat the index_data.json File Looks Like (Snippet) Here‚Äôs a peek at what‚Äôs inside index_data.json. It‚Äôs a structured way to store our pre-computed search data:\nsrc/main/resources/data/index_data.json (Snippet)\n{ \"invertedIndex\" : { \"python\" : [ { \"docId\" : 13, \"freq\" : 1, \"positions\" : [ 18 ] }, { \"docId\" : 26, \"freq\" : 4, \"positions\" : [ 0, 11, 16, 17 ] } ], \"algorithm\" : [ { \"docId\" 1, \"freq\" : 5, \"positions\" : [ 2, 15, 25, 26, 29 ] }, { \"docId\" : 13, \"freq\" : 4, \"positions\" : [ 1, 13, 17, 21 ] } ] }, \"tfIdfVectors\" : { \"1\" : { \"rivest\" : 2.31, \"stein\" : 2.31, \"code\" : 1.01 }, \"2\" : { \"profession\" : 1.83, \"engin\" : 0.95, \"practic\" : 0.45 } }, \"idfScores\" : { \"python\" : 0.769, \"algorithm\" : 0.952, \"java\" : 0.952 } } invertedIndex: Maps a word (like ‚Äúpython‚Äù) to a list of ‚Äúpostings.‚Äù A ‚Äúposting‚Äù tells us a docId (book ID), how many times the word appears (freq), and its positions in that book. tfIdfVectors: For each book‚Äôs docId (like ‚Äú1‚Äù), it lists the important terms (words) in that book and their ‚Äúimportance score‚Äù (tfIdf). idfScores: For each term (word), it lists its idf (overall rarity/importance score) across all books. Under the Hood: Building the Search Index Step-by-Step Let‚Äôs visualize the entire process of how the IndexerMain builds this powerful index:\nsequenceDiagram participant IndexerMain participant BookLoader participant TextProcessor participant IndexBuilder participant TfIdfCalculator participant index_data.json IndexerMain-\u003e\u003eBookLoader: \"Load all books from book.json\" BookLoader--\u003e\u003eIndexerMain: \"Here's a list of Book objects!\" loop For each Book IndexerMain-\u003e\u003eTextProcessor: \"Clean text from title, description, etc.\" Note over TextProcessor: Removes common words, normalizes spellings (Chapter 5) TextProcessor--\u003e\u003eIndexerMain: \"Here are the important, clean words (tokens)!\" IndexerMain-\u003e\u003eIndexBuilder: \"Add these tokens and book ID to the Inverted Index\" Note over IndexBuilder: Records which words are in which book, their count, and positions. end IndexerMain-\u003e\u003eTfIdfCalculator: \"Calculate IDF (overall word rarity) for all words\" IndexerMain-\u003e\u003eTfIdfCalculator: \"Calculate TF-IDF (word importance) for each word in each book\" TfIdfCalculator--\u003e\u003eIndexerMain: \"Here are all the TF-IDF scores!\" IndexerMain-\u003e\u003eindex_data.json: \"Save Inverted Index, TF-IDF scores to index_data.json\" IndexerMain--\u003e\u003eIndexerMain: Cleanup \u0026 Finish 1. Storing the Index Data: SearchIndexData This class is a simple container to hold all the different parts of our pre-computed index together. It‚Äôs the blueprint for how our index_data.json file is structured.\nsrc/main/java/domain/SearchIndexData.java (Simplified)\npackage domain; import lombok.Getter; // Automatically creates 'get' methods import java.util.List; import java.util.Map; public class SearchIndexData { @Getter private Map\u003cString, List\u003cPosting\u003e\u003e invertedIndex; // Maps word -\u003e list of its locations @Getter private Map\u003cInteger, Map\u003cString, Double\u003e\u003e tfIdfVectors; // Maps book ID -\u003e (word -\u003e TF-IDF score) @Getter private Map\u003cString, Double\u003e idfScores; // Maps word -\u003e its overall rarity score public SearchIndexData() {} // Constructor for JSON loading public SearchIndexData(Map\u003cString, List\u003cPosting\u003e\u003e invertedIndex, Map\u003cInteger, Map\u003cString, Double\u003e\u003e tfIdfVectors, Map\u003cString, Double\u003e idfScores) { this.invertedIndex = invertedIndex; this.tfIdfVectors = tfIdfVectors; this.idfScores = idfScores; } } This class makes it easy to save and load the entire complex index data as one unit using JSON.\n2. Loading the Index for the Application: IndexLoader Once IndexerMain has created index_data.json, the main DevShelf application (as seen in Application Orchestration) needs to load this file when it starts up. This is the job of the IndexLoader.\nsrc/main/java/storage/IndexLoader.java (Simplified loadIndex method)\npackage storage; import com.fasterxml.jackson.databind.ObjectMapper; import domain.SearchIndexData; import java.io.File; import java.io.IOException; import java.io.InputStream; public class IndexLoader { private final String resourcePath; public IndexLoader(String resourcePath) { this.resourcePath = resourcePath; } public SearchIndexData loadIndex() { ObjectMapper mapper = new ObjectMapper(); // Our JSON reading tool System.out.println(\"üì¶ Loading pre-compiled index...\"); try (InputStream inputStream = getClass().getResourceAsStream(resourcePath)) { if (inputStream == null) { // If the default index is not found, something is wrong. throw new RuntimeException(\"Resource not found: \" + resourcePath); } // This magical line reads the JSON file and converts it into a SearchIndexData object! SearchIndexData indexData = mapper.readValue(inputStream, SearchIndexData.class); System.out.println(\"Index loaded successfully.\"); return indexData; } catch (IOException e) { System.err.println(\"FATAL ERROR: Could not load index file. \" + e.getMessage()); throw new RuntimeException(\"Failed to load search index\", e); // Crash if no index } } } The IndexLoader quickly reads the index_data.json file. If the file is missing or corrupted, DevShelf cannot function, so it will stop the application with an error. But if successful, it provides the entire SearchIndexData object to the core application logic, making it ready for instant searches.\n3. Building the Inverted Index: IndexBuilder This is where the actual ‚Äúindexing‚Äù of individual books happens. The IndexBuilder takes a Book (Domain Model) object, extracts and cleans its text, and then adds its words to the invertedIndex.\nsrc/main/java/features/search/IndexBuilder.java (Simplified indexDocument method)\npackage features.search; import domain.Book; import domain.Posting; import utils.TextProcessor; // Our text cleaning tool from Chapter 5 import java.util.ArrayList; import java.util.HashMap; import java.util.List; import java.util.Map; public class IndexBuilder { @Getter private final Map\u003cString, List\u003cPosting\u003e\u003e invertedIndex; // The main index: word -\u003e list of book locations private final TextProcessor textProcessor; public IndexBuilder(TextProcessor textProcessor) { this.textProcessor = textProcessor; this.invertedIndex = new HashMap\u003c\u003e(); } public void indexDocument(Book book) { // 1. Combine all relevant text about the book String bookData = book.getTitle() + \" \" + book.getAuthor() + \" \" + book.getDescription() + \" \" + book.getCategory() + \" \" + book.getProgLang() + \" \" + String.join(\" \", book.getTag()); // 2. Clean and normalize the text (uses TextProcessor from Chapter 5) List\u003cString\u003e stemmedTokens = textProcessor.process(bookData); // 3. Record each term's positions and frequency within THIS book Map\u003cString, List\u003cInteger\u003e\u003e termPositionsInThisBook = new HashMap\u003c\u003e(); for (int pos = 0; pos \u003c stemmedTokens.size(); pos++) { String term = stemmedTokens.get(pos); termPositionsInThisBook.computeIfAbsent(term, k -\u003e new ArrayList\u003c\u003e()).add(pos); } // 4. Add this book's data to the overall inverted index for (Map.Entry\u003cString, List\u003cInteger\u003e\u003e entry : termPositionsInThisBook.entrySet()) { String term = entry.getKey(); List\u003cInteger\u003e positions = entry.getValue(); // A Posting records a book ID, how many times the term appeared (frequency), and its positions Posting posting = new Posting(book.getBookId(), positions.size(), positions); // Add this posting to the list for this term in the inverted index invertedIndex.computeIfAbsent(term, k -\u003e new ArrayList\u003c\u003e()).add(posting); } } } The indexDocument method is run for each book:\nIt collects all descriptive text for the book. It uses the textProcessor (our ‚Äúdigital editor‚Äù from Text Preprocessing) to clean and standardize the words. It then counts how often each word appears in this specific book and notes its positions. Finally, it creates a Posting object with this information (bookId, word count, positions) and adds it to the invertedIndex for that specific word. 4. Calculating Word Importance: TfIdfCalculator After the invertedIndex is built for all books, the TfIdfCalculator then goes through all the words and books to figure out their TF-IDF scores.\nsrc/main/java/utils/TfIdfCalculator.java (Simplified calculateIdf and calculateTfIdf methods)\npackage utils; import domain.Posting; import lombok.Getter; import java.util.HashMap; import java.util.List; import java.util.Map; public class TfIdfCalculator { @Getter private Map\u003cInteger, Map\u003cString, Double\u003e\u003e tfIdfVectors = new HashMap\u003c\u003e(); // Book ID -\u003e (Word -\u003e TF-IDF Score) @Getter private Map\u003cString, Double\u003e idfScores = new HashMap\u003c\u003e(); // Word -\u003e Overall Rarity Score public void calculateIdf(Map\u003cString, List\u003cPosting\u003e\u003e invertedIndex, int totalDocCount) { System.out.println(\"Calculating IDF scores for \" + invertedIndex.size() + \" terms...\"); for(String term : invertedIndex.keySet()) { // How many documents (books) contain this term int docFrequency = invertedIndex.get(term).size(); // IDF: The rarer the term (lower docFrequency), the higher its IDF score double idf = Math.log10( (double) totalDocCount / docFrequency ); idfScores.put(term, idf); // Store overall rarity score for each term } } public void calculateTfIdf(Map\u003cString, List\u003cPosting\u003e\u003e invertedIndex) { System.out.println(\"Calculating TF-IDF vectors for all documents...\"); for(String term : invertedIndex.keySet()) { double idf = idfScores.get(term); // Get the term's overall rarity score List\u003cPosting\u003e postings = invertedIndex.get(term); for(Posting posting : postings ) { int docId = posting.getDocId(); int termFreq = posting.getFreq(); // How many times this term appears in THIS book // TF: More frequent in this book means higher TF double tf = 1 + Math.log10(termFreq); double tfIdf = tf * idf; // Combine TF (local importance) and IDF (global rarity) // Store this word's TF-IDF score for this specific book tfIdfVectors.computeIfAbsent(docId, k -\u003e new HashMap\u003c\u003e()).put(term, tfIdf); } } System.out.println(\"TF-IDF calculation complete.\"); } } calculateIdf: This method first calculates the Inverse Document Frequency (IDF) for every unique word across all books. Words that are very common (like ‚Äúprogramming‚Äù) will have a low IDF, while unique words will have a high IDF. calculateTfIdf: Then, for each word in each book, it calculates the Term Frequency-Inverse Document Frequency (TF-IDF). This score combines how often a word appears in a specific book (Term Frequency) with how rare that word is across the entire library (IDF). A high TF-IDF means a word is very important and unique to a document. Why Offline Search Indexing is So Important This pre-computation step might seem like a lot of work, but it‚Äôs absolutely vital for DevShelf‚Äôs performance and user experience:\nFeature WITHOUT Offline Search Indexing WITH Offline Search Indexing Search Speed Very slow, as each query requires re-scanning all books and recalculating scores. Instant! DevShelf just looks up words and scores in pre-built tables. Efficiency Wastes computer resources by repeating calculations for every search. Calculations done once, data loaded quickly, saving resources during live use. Relevance Harder to accurately rank results without pre-computed word importance scores. Accurate ranking based on scientifically calculated TF-IDF scores. Scalability Slows down dramatically as more books are added. Stays fast even with thousands of books, as the heavy work is done beforehand. Conclusion In this chapter, we uncovered the essential process of Offline Search Indexing. We learned that:\nIt‚Äôs an offline process performed by IndexerMain to prepare book data for lightning-fast searches. It builds two crucial lookup tables: the Inverted Index (mapping words to books) and TF-IDF scores (measuring a word‚Äôs importance to a book and its overall rarity). The IndexBuilder meticulously processes each book‚Äôs text (using our Text Preprocessing tools) to populate the inverted index. The TfIdfCalculator then assigns numerical importance scores to every word in every book. All this prepared data is saved into a file (index_data.json) and efficiently loaded by the IndexLoader when DevShelf starts, turning our digital library into an instant search powerhouse. This clever preparation is the foundation upon which DevShelf can provide quick and intelligent search results. Now that DevShelf knows how to find the right books, let‚Äôs explore how it can make those search results even smarter and more helpful!\n","wordCount":"2552","inLanguage":"en","datePublished":"2024-11-01T00:00:00Z","dateModified":"2024-11-01T00:00:00Z","author":{"@type":"Person","name":"Muhammad Qasim"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://kas-sim.github.io/posts/building-search-engine-from-scratch/"},"publisher":{"@type":"Organization","name":"Muhammad Qasim","logo":{"@type":"ImageObject","url":"https://kas-sim.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://kas-sim.github.io/ accesskey=h title="Muhammad Qasim (Alt + H)">Muhammad Qasim</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://kas-sim.github.io/systems/ title=Systems><span>Systems</span></a></li><li><a href=https://kas-sim.github.io/rag-notes/ title="RAG Notes"><span>RAG Notes</span></a></li><li><a href=https://kas-sim.github.io/tools/ title=Tools><span>Tools</span></a></li><li><a href=https://kas-sim.github.io/archives/ title=Archive><span>Archive</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://kas-sim.github.io/>Home</a>&nbsp;¬ª&nbsp;<a href=https://kas-sim.github.io/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">From O(N) to O(1): Building a Java Search Engine from Scratch</h1><div class=post-description>How I built a Positional Inverted Index and TF-IDF ranker without using Lucene or Elasticsearch.</div><div class=post-meta><span title='2024-11-01 00:00:00 +0000 UTC'>November 1, 2024</span>&nbsp;¬∑&nbsp;<span>Muhammad Qasim</span></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><ul><li><a href=#the-problem-with-linear-search aria-label="The Problem with Linear Search">The Problem with Linear Search</a></li><li><a href=#the-solution-offline-inverted-indexing aria-label="The Solution: Offline Inverted Indexing">The Solution: Offline Inverted Indexing</a><ul><li><a href=#what-problem-does-the-secret-catalog-solve aria-label="What Problem Does the &ldquo;Secret Catalog&rdquo; Solve?">What Problem Does the &ldquo;Secret Catalog&rdquo; Solve?</a></li><li><a href=#key-concepts-of-offline-search-indexing aria-label="Key Concepts of Offline Search Indexing">Key Concepts of Offline Search Indexing</a></li><li><a href=#how-to-build-the-search-index aria-label="How to Build the Search Index">How to Build the Search Index</a><ul><li><a href=#what-the-index_datajson-file-looks-like-snippet aria-label="What the index_data.json File Looks Like (Snippet)">What the index_data.json File Looks Like (Snippet)</a></li></ul></li><li><a href=#under-the-hood-building-the-search-index-step-by-step aria-label="Under the Hood: Building the Search Index Step-by-Step">Under the Hood: Building the Search Index Step-by-Step</a><ul><li><a href=#1-storing-the-index-data-searchindexdata aria-label="1. Storing the Index Data: SearchIndexData">1. Storing the Index Data: SearchIndexData</a></li><li><a href=#2-loading-the-index-for-the-application-indexloader aria-label="2. Loading the Index for the Application: IndexLoader">2. Loading the Index for the Application: IndexLoader</a></li><li><a href=#3-building-the-inverted-index-indexbuilder aria-label="3. Building the Inverted Index: IndexBuilder">3. Building the Inverted Index: IndexBuilder</a></li><li><a href=#4-calculating-word-importance-tfidfcalculator aria-label="4. Calculating Word Importance: TfIdfCalculator">4. Calculating Word Importance: TfIdfCalculator</a></li></ul></li><li><a href=#why-offline-search-indexing-is-so-important aria-label="Why Offline Search Indexing is So Important">Why Offline Search Indexing is So Important</a></li><li><a href=#conclusion aria-label=Conclusion>Conclusion</a></li></ul></li></ul></div></details></div><div class=post-content><p><em>Note: This is an architectural deep-dive into the core indexing engine of <a href=/projects/devshelf>DevShelf</a>.</em></p><h2 id=the-problem-with-linear-search>The Problem with Linear Search<a hidden class=anchor aria-hidden=true href=#the-problem-with-linear-search>#</a></h2><p>When I started building DevShelf, the naive approach was simple: load all books into a <code>List&lt;Book></code> and loop through them checking <code>if (book.contains(query))</code>.</p><p>For 10 books, this is fine. For 1,000 books, it&rsquo;s slow. For 1,000,000 books, the system crashes. This is an $O(N \cdot M)$ operation, where $N$ is books and $M$ is words. We needed $O(1)$.</p><h2 id=the-solution-offline-inverted-indexing>The Solution: Offline Inverted Indexing<a hidden class=anchor aria-hidden=true href=#the-solution-offline-inverted-indexing>#</a></h2><p>To solve this, I implemented an <strong>Offline Indexer</strong> (<code>IndexerMain</code>) that pre-processes the data&mldr;</p><h3 id=what-problem-does-the-secret-catalog-solve>What Problem Does the &ldquo;Secret Catalog&rdquo; Solve?<a hidden class=anchor aria-hidden=true href=#what-problem-does-the-secret-catalog-solve>#</a></h3><p>Imagine DevShelf has hundreds or even thousands of books. If you search for &ldquo;Python machine learning,&rdquo; DevShelf can&rsquo;t just scan every single book&rsquo;s title, author, and description in real-time. That would be too slow and would make your search results appear with a frustrating delay.</p><p>The problem Offline Search Indexing solves is this: <strong>How can DevShelf provide instant search results for thousands of books without having to read them all every time you type a query?</strong></p><p>Our central use case: <strong>When you start DevShelf, it should be ready to give you instant, relevant search results for any query, big or small.</strong></p><p>To achieve this, DevShelf does a lot of heavy lifting <em>once</em>, in advance. It builds special &ldquo;lookup tables&rdquo; that are super quick to check, like a meticulously organized index for the entire library.</p><h3 id=key-concepts-of-offline-search-indexing>Key Concepts of Offline Search Indexing<a hidden class=anchor aria-hidden=true href=#key-concepts-of-offline-search-indexing>#</a></h3><p>Offline Search Indexing involves a special process that creates these fast lookup tables:</p><ol><li><p><strong>It&rsquo;s an Offline Process:</strong> This means it&rsquo;s a separate program you run once, or whenever new books are added. It doesn&rsquo;t run every time DevShelf starts. Think of it as updating the library&rsquo;s main card catalog overnight, so it&rsquo;s ready for customers in the morning.</p></li><li><p><strong>Building the Inverted Index:</strong> This is like the index at the back of a textbook, but for our entire library!</p><ul><li>You look up a <strong>word</strong> (like &ldquo;python&rdquo;).</li><li>It quickly tells you <strong>all the books</strong> that contain that word, and even where it appears.</li><li>It &ldquo;inverts&rdquo; the usual way of thinking (book -> words) to (word -> books).</li></ul></li><li><p><strong>Calculating TF-IDF Scores:</strong> This helps DevShelf understand <em>how important</em> a word is to a specific book, compared to its importance across <em>all</em> books.</p><ul><li><strong>TF (Term Frequency):</strong> How many times a word appears in <em>one book</em>. More occurrences mean more importance <em>to that book</em>.</li><li><strong>IDF (Inverse Document Frequency):</strong> How <em>rare</em> a word is across <em>all books</em>. A rare word (like &ldquo;quantum entanglement&rdquo;) is more significant than a common word (like &ldquo;programming&rdquo;).</li><li><strong>TF-IDF = TF * IDF:</strong> This combined score tells us the overall &ldquo;importance&rdquo; of a word in a specific book, helping DevShelf rank results more intelligently.</li></ul></li></ol><p>These pre-computed data (the inverted index and all the TF-IDF scores) are then saved into a special file.</p><h3 id=how-to-build-the-search-index>How to Build the Search Index<a hidden class=anchor aria-hidden=true href=#how-to-build-the-search-index>#</a></h3><p>You use a special program called <code>IndexerMain</code> (short for &ldquo;Indexer Main Program&rdquo;) to do all this work. You usually run it directly from your computer&rsquo;s terminal, not through DevShelf&rsquo;s normal interface. It&rsquo;s like a dedicated librarian assistant who spends hours organizing the catalog.</p><p><strong><code>src/main/java/core/IndexerMain.java</code> (Simplified)</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> core;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> domain.Book;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> domain.SearchIndexData;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> features.search.IndexBuilder;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> storage.BookLoader;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> utils.TextProcessor;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> utils.TfIdfCalculator;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> com.fasterxml.jackson.databind.ObjectMapper; <span style=color:#75715e>// Tool to save to JSON</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.io.File;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.List;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.Set;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>IndexerMain</span> {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// This is where our super-fast index will be saved</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>final</span> String INDEX_OUTPUT_PATH <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;src/main/resources/data/index_data.json&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args) {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;--- Starting Offline Indexer ---&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 1. Prepare our tools</span>
</span></span><span style=display:flex><span>            Set<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> stopWords <span style=color:#f92672>=</span> StopWordLoader.<span style=color:#a6e22e>loadStopWords</span>(<span style=color:#e6db74>&#34;/data/stopword.txt&#34;</span>);
</span></span><span style=display:flex><span>            TextProcessor textProcessor <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> TextProcessor(stopWords);
</span></span><span style=display:flex><span>            BookLoader bookLoader <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> BookLoader(<span style=color:#e6db74>&#34;/data/book.json&#34;</span>);
</span></span><span style=display:flex><span>            IndexBuilder indexer <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> IndexBuilder(textProcessor);
</span></span><span style=display:flex><span>            TfIdfCalculator tfIdfCalculator <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> TfIdfCalculator();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 2. Load all the books (from Chapter 2)</span>
</span></span><span style=display:flex><span>            List<span style=color:#f92672>&lt;</span>Book<span style=color:#f92672>&gt;</span> allBooks <span style=color:#f92672>=</span> bookLoader.<span style=color:#a6e22e>loadBooks</span>();
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Loading and indexing &#34;</span> <span style=color:#f92672>+</span> allBooks.<span style=color:#a6e22e>size</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; books...&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 3. Build the Inverted Index for each book</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(Book book : allBooks) {
</span></span><span style=display:flex><span>                indexer.<span style=color:#a6e22e>indexDocument</span>(book); <span style=color:#75715e>// This analyzes each book&#39;s text</span>
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Indexing Complete. Found &#34;</span> <span style=color:#f92672>+</span> indexer.<span style=color:#a6e22e>getInvertedIndex</span>().<span style=color:#a6e22e>size</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; unique terms.&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 4. Calculate TF-IDF scores based on the inverted index</span>
</span></span><span style=display:flex><span>            tfIdfCalculator.<span style=color:#a6e22e>calculateIdf</span>(indexer.<span style=color:#a6e22e>getInvertedIndex</span>(), allBooks.<span style=color:#a6e22e>size</span>());
</span></span><span style=display:flex><span>            tfIdfCalculator.<span style=color:#a6e22e>calculateTfIdf</span>(indexer.<span style=color:#a6e22e>getInvertedIndex</span>());
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;TF-IDF calculation complete.&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 5. Gather all the index data into one object</span>
</span></span><span style=display:flex><span>            SearchIndexData indexData <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> SearchIndexData(
</span></span><span style=display:flex><span>                indexer.<span style=color:#a6e22e>getInvertedIndex</span>(),
</span></span><span style=display:flex><span>                tfIdfCalculator.<span style=color:#a6e22e>getTfIdfVectors</span>(),
</span></span><span style=display:flex><span>                tfIdfCalculator.<span style=color:#a6e22e>getIdfScores</span>()
</span></span><span style=display:flex><span>            );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#75715e>// 6. Save this data to a file (index_data.json)</span>
</span></span><span style=display:flex><span>            ObjectMapper mapper <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ObjectMapper(); <span style=color:#75715e>// Our JSON saving tool</span>
</span></span><span style=display:flex><span>            mapper.<span style=color:#a6e22e>writeValue</span>(<span style=color:#66d9ef>new</span> File(INDEX_OUTPUT_PATH), indexData); <span style=color:#75715e>// Write the data</span>
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;--- ‚úÖ Indexer Finished Successfully! --- &#34;</span>);
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (Exception e) {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34; --- ‚ùå Indexer failed with an error. --- &#34;</span>);
</span></span><span style=display:flex><span>            e.<span style=color:#a6e22e>printStackTrace</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>When you run <code>IndexerMain</code>, it does the following:</p><ol><li><strong>Gets Ready</strong>: It loads the <a href=05_text_preprocessing_.md>Text Preprocessing</a> tools and the <a href=02_book__domain_model__.md>Book (Domain Model)</a> loader.</li><li><strong>Loads Books</strong>: It reads all the books from <code>book.json</code>.</li><li><strong>Indexes Books</strong>: For each book, it uses the <code>IndexBuilder</code> to create entries in the inverted index.</li><li><strong>Calculates Scores</strong>: It then uses the <code>TfIdfCalculator</code> to figure out the importance of each word in each book.</li><li><strong>Saves Everything</strong>: All this organized data is bundled into a <code>SearchIndexData</code> object and saved as a file named <code>index_data.json</code>.</li></ol><p>After <code>IndexerMain</code> finishes, the <code>index_data.json</code> file is created. This file holds all the &ldquo;secret catalog&rdquo; information, ready for DevShelf to use when it starts.</p><h4 id=what-the-index_datajson-file-looks-like-snippet>What the <code>index_data.json</code> File Looks Like (Snippet)<a hidden class=anchor aria-hidden=true href=#what-the-index_datajson-file-looks-like-snippet>#</a></h4><p>Here&rsquo;s a peek at what&rsquo;s inside <code>index_data.json</code>. It&rsquo;s a structured way to store our pre-computed search data:</p><p><strong><code>src/main/resources/data/index_data.json</code> (Snippet)</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-json data-lang=json><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;invertedIndex&#34;</span> : {
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;python&#34;</span> : [
</span></span><span style=display:flex><span>      { <span style=color:#f92672>&#34;docId&#34;</span> : <span style=color:#ae81ff>13</span>, <span style=color:#f92672>&#34;freq&#34;</span> : <span style=color:#ae81ff>1</span>, <span style=color:#f92672>&#34;positions&#34;</span> : [ <span style=color:#ae81ff>18</span> ] },
</span></span><span style=display:flex><span>      { <span style=color:#f92672>&#34;docId&#34;</span> : <span style=color:#ae81ff>26</span>, <span style=color:#f92672>&#34;freq&#34;</span> : <span style=color:#ae81ff>4</span>, <span style=color:#f92672>&#34;positions&#34;</span> : [ <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>11</span>, <span style=color:#ae81ff>16</span>, <span style=color:#ae81ff>17</span> ] }
</span></span><span style=display:flex><span>    ],
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;algorithm&#34;</span> : [
</span></span><span style=display:flex><span>      { <span style=color:#f92672>&#34;docId&#34;</span> <span style=color:#ae81ff>1</span>, <span style=color:#f92672>&#34;freq&#34;</span> : <span style=color:#ae81ff>5</span>, <span style=color:#f92672>&#34;positions&#34;</span> : [ <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>15</span>, <span style=color:#ae81ff>25</span>, <span style=color:#ae81ff>26</span>, <span style=color:#ae81ff>29</span> ] },
</span></span><span style=display:flex><span>      { <span style=color:#f92672>&#34;docId&#34;</span> : <span style=color:#ae81ff>13</span>, <span style=color:#f92672>&#34;freq&#34;</span> : <span style=color:#ae81ff>4</span>, <span style=color:#f92672>&#34;positions&#34;</span> : [ <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>13</span>, <span style=color:#ae81ff>17</span>, <span style=color:#ae81ff>21</span> ] }
</span></span><span style=display:flex><span>    ]
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;tfIdfVectors&#34;</span> : {
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;1&#34;</span> : { <span style=color:#f92672>&#34;rivest&#34;</span> : <span style=color:#ae81ff>2.31</span>, <span style=color:#f92672>&#34;stein&#34;</span> : <span style=color:#ae81ff>2.31</span>, <span style=color:#f92672>&#34;code&#34;</span> : <span style=color:#ae81ff>1.01</span> },
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;2&#34;</span> : { <span style=color:#f92672>&#34;profession&#34;</span> : <span style=color:#ae81ff>1.83</span>, <span style=color:#f92672>&#34;engin&#34;</span> : <span style=color:#ae81ff>0.95</span>, <span style=color:#f92672>&#34;practic&#34;</span> : <span style=color:#ae81ff>0.45</span> }
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#f92672>&#34;idfScores&#34;</span> : {
</span></span><span style=display:flex><span>    <span style=color:#f92672>&#34;python&#34;</span> : <span style=color:#ae81ff>0.769</span>, <span style=color:#f92672>&#34;algorithm&#34;</span> : <span style=color:#ae81ff>0.952</span>, <span style=color:#f92672>&#34;java&#34;</span> : <span style=color:#ae81ff>0.952</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>invertedIndex</code>: Maps a word (like &ldquo;python&rdquo;) to a list of &ldquo;postings.&rdquo; A &ldquo;posting&rdquo; tells us a <code>docId</code> (book ID), how many times the word appears (<code>freq</code>), and its <code>positions</code> in that book.</li><li><code>tfIdfVectors</code>: For each book&rsquo;s <code>docId</code> (like &ldquo;1&rdquo;), it lists the important <code>term</code>s (words) in that book and their &ldquo;importance score&rdquo; (<code>tfIdf</code>).</li><li><code>idfScores</code>: For each <code>term</code> (word), it lists its <code>idf</code> (overall rarity/importance score) across <em>all</em> books.</li></ul><h3 id=under-the-hood-building-the-search-index-step-by-step>Under the Hood: Building the Search Index Step-by-Step<a hidden class=anchor aria-hidden=true href=#under-the-hood-building-the-search-index-step-by-step>#</a></h3><p>Let&rsquo;s visualize the entire process of how the <code>IndexerMain</code> builds this powerful index:</p><pre tabindex=0><code class=language-mermaid data-lang=mermaid>sequenceDiagram
    participant IndexerMain
    participant BookLoader
    participant TextProcessor
    participant IndexBuilder
    participant TfIdfCalculator
    participant index_data.json

    IndexerMain-&gt;&gt;BookLoader: &#34;Load all books from book.json&#34;
    BookLoader--&gt;&gt;IndexerMain: &#34;Here&#39;s a list of Book objects!&#34;
    loop For each Book
        IndexerMain-&gt;&gt;TextProcessor: &#34;Clean text from title, description, etc.&#34;
        Note over TextProcessor: Removes common words, normalizes spellings (Chapter 5)
        TextProcessor--&gt;&gt;IndexerMain: &#34;Here are the important, clean words (tokens)!&#34;
        IndexerMain-&gt;&gt;IndexBuilder: &#34;Add these tokens and book ID to the Inverted Index&#34;
        Note over IndexBuilder: Records which words are in which book, their count, and positions.
    end
    IndexerMain-&gt;&gt;TfIdfCalculator: &#34;Calculate IDF (overall word rarity) for all words&#34;
    IndexerMain-&gt;&gt;TfIdfCalculator: &#34;Calculate TF-IDF (word importance) for each word in each book&#34;
    TfIdfCalculator--&gt;&gt;IndexerMain: &#34;Here are all the TF-IDF scores!&#34;
    IndexerMain-&gt;&gt;index_data.json: &#34;Save Inverted Index, TF-IDF scores to index_data.json&#34;
    IndexerMain--&gt;&gt;IndexerMain: Cleanup &amp; Finish
</code></pre><h4 id=1-storing-the-index-data-searchindexdata>1. Storing the Index Data: <code>SearchIndexData</code><a hidden class=anchor aria-hidden=true href=#1-storing-the-index-data-searchindexdata>#</a></h4><p>This class is a simple container to hold all the different parts of our pre-computed index together. It&rsquo;s the blueprint for how our <code>index_data.json</code> file is structured.</p><p><strong><code>src/main/java/domain/SearchIndexData.java</code> (Simplified)</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> domain;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> lombok.Getter; <span style=color:#75715e>// Automatically creates &#39;get&#39; methods</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.List;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.Map;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>SearchIndexData</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Getter</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Map<span style=color:#f92672>&lt;</span>String, List<span style=color:#f92672>&lt;</span>Posting<span style=color:#f92672>&gt;&gt;</span> invertedIndex; <span style=color:#75715e>// Maps word -&gt; list of its locations</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Getter</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Map<span style=color:#f92672>&lt;</span>Integer, Map<span style=color:#f92672>&lt;</span>String, Double<span style=color:#f92672>&gt;&gt;</span> tfIdfVectors; <span style=color:#75715e>// Maps book ID -&gt; (word -&gt; TF-IDF score)</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Getter</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Map<span style=color:#f92672>&lt;</span>String, Double<span style=color:#f92672>&gt;</span> idfScores; <span style=color:#75715e>// Maps word -&gt; its overall rarity score</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>SearchIndexData</span>() {} <span style=color:#75715e>// Constructor for JSON loading</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>SearchIndexData</span>(Map<span style=color:#f92672>&lt;</span>String, List<span style=color:#f92672>&lt;</span>Posting<span style=color:#f92672>&gt;&gt;</span> invertedIndex,
</span></span><span style=display:flex><span>                           Map<span style=color:#f92672>&lt;</span>Integer, Map<span style=color:#f92672>&lt;</span>String, Double<span style=color:#f92672>&gt;&gt;</span> tfIdfVectors,
</span></span><span style=display:flex><span>                           Map<span style=color:#f92672>&lt;</span>String, Double<span style=color:#f92672>&gt;</span> idfScores) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>invertedIndex</span> <span style=color:#f92672>=</span> invertedIndex;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>tfIdfVectors</span> <span style=color:#f92672>=</span> tfIdfVectors;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>idfScores</span> <span style=color:#f92672>=</span> idfScores;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This class makes it easy to save and load the entire complex index data as one unit using JSON.</p><h4 id=2-loading-the-index-for-the-application-indexloader>2. Loading the Index for the Application: <code>IndexLoader</code><a hidden class=anchor aria-hidden=true href=#2-loading-the-index-for-the-application-indexloader>#</a></h4><p>Once <code>IndexerMain</code> has created <code>index_data.json</code>, the main DevShelf application (as seen in <a href=03_application_orchestration_.md>Application Orchestration</a>) needs to load this file when it starts up. This is the job of the <code>IndexLoader</code>.</p><p><strong><code>src/main/java/storage/IndexLoader.java</code> (Simplified <code>loadIndex</code> method)</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> storage;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> com.fasterxml.jackson.databind.ObjectMapper;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> domain.SearchIndexData;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.io.File;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.io.IOException;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.io.InputStream;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>IndexLoader</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> String resourcePath;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>IndexLoader</span>(String resourcePath) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>resourcePath</span> <span style=color:#f92672>=</span> resourcePath;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> SearchIndexData <span style=color:#a6e22e>loadIndex</span>() {
</span></span><span style=display:flex><span>        ObjectMapper mapper <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> ObjectMapper(); <span style=color:#75715e>// Our JSON reading tool</span>
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;üì¶ Loading pre-compiled index...&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> (InputStream inputStream <span style=color:#f92672>=</span> getClass().<span style=color:#a6e22e>getResourceAsStream</span>(resourcePath)) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (inputStream <span style=color:#f92672>==</span> <span style=color:#66d9ef>null</span>) {
</span></span><span style=display:flex><span>                <span style=color:#75715e>// If the default index is not found, something is wrong.</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException(<span style=color:#e6db74>&#34;Resource not found: &#34;</span> <span style=color:#f92672>+</span> resourcePath);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#75715e>// This magical line reads the JSON file and converts it into a SearchIndexData object!</span>
</span></span><span style=display:flex><span>            SearchIndexData indexData <span style=color:#f92672>=</span> mapper.<span style=color:#a6e22e>readValue</span>(inputStream, SearchIndexData.<span style=color:#a6e22e>class</span>);
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Index loaded successfully.&#34;</span>);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> indexData;
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (IOException e) {
</span></span><span style=display:flex><span>            System.<span style=color:#a6e22e>err</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;FATAL ERROR: Could not load index file. &#34;</span> <span style=color:#f92672>+</span> e.<span style=color:#a6e22e>getMessage</span>());
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>throw</span> <span style=color:#66d9ef>new</span> RuntimeException(<span style=color:#e6db74>&#34;Failed to load search index&#34;</span>, e); <span style=color:#75715e>// Crash if no index</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>IndexLoader</code> quickly reads the <code>index_data.json</code> file. If the file is missing or corrupted, DevShelf cannot function, so it will stop the application with an error. But if successful, it provides the entire <code>SearchIndexData</code> object to the core application logic, making it ready for instant searches.</p><h4 id=3-building-the-inverted-index-indexbuilder>3. Building the Inverted Index: <code>IndexBuilder</code><a hidden class=anchor aria-hidden=true href=#3-building-the-inverted-index-indexbuilder>#</a></h4><p>This is where the actual &ldquo;indexing&rdquo; of individual books happens. The <code>IndexBuilder</code> takes a <a href=02_book__domain_model__.md>Book (Domain Model)</a> object, extracts and cleans its text, and then adds its words to the <code>invertedIndex</code>.</p><p><strong><code>src/main/java/features/search/IndexBuilder.java</code> (Simplified <code>indexDocument</code> method)</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> features.search;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> domain.Book;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> domain.Posting;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> utils.TextProcessor; <span style=color:#75715e>// Our text cleaning tool from Chapter 5</span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.ArrayList;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.HashMap;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.List;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.Map;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>IndexBuilder</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Getter</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> Map<span style=color:#f92672>&lt;</span>String, List<span style=color:#f92672>&lt;</span>Posting<span style=color:#f92672>&gt;&gt;</span> invertedIndex; <span style=color:#75715e>// The main index: word -&gt; list of book locations</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>final</span> TextProcessor textProcessor;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>IndexBuilder</span>(TextProcessor textProcessor) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>textProcessor</span> <span style=color:#f92672>=</span> textProcessor;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>invertedIndex</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>indexDocument</span>(Book book) {
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 1. Combine all relevant text about the book</span>
</span></span><span style=display:flex><span>        String bookData <span style=color:#f92672>=</span> book.<span style=color:#a6e22e>getTitle</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; &#34;</span> <span style=color:#f92672>+</span> book.<span style=color:#a6e22e>getAuthor</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; &#34;</span> <span style=color:#f92672>+</span> book.<span style=color:#a6e22e>getDescription</span>() <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                          <span style=color:#e6db74>&#34; &#34;</span> <span style=color:#f92672>+</span> book.<span style=color:#a6e22e>getCategory</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; &#34;</span> <span style=color:#f92672>+</span> book.<span style=color:#a6e22e>getProgLang</span>() <span style=color:#f92672>+</span>
</span></span><span style=display:flex><span>                          <span style=color:#e6db74>&#34; &#34;</span> <span style=color:#f92672>+</span> String.<span style=color:#a6e22e>join</span>(<span style=color:#e6db74>&#34; &#34;</span>, book.<span style=color:#a6e22e>getTag</span>());
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 2. Clean and normalize the text (uses TextProcessor from Chapter 5)</span>
</span></span><span style=display:flex><span>        List<span style=color:#f92672>&lt;</span>String<span style=color:#f92672>&gt;</span> stemmedTokens <span style=color:#f92672>=</span> textProcessor.<span style=color:#a6e22e>process</span>(bookData);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 3. Record each term&#39;s positions and frequency within THIS book</span>
</span></span><span style=display:flex><span>        Map<span style=color:#f92672>&lt;</span>String, List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;&gt;</span> termPositionsInThisBook <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;</span>();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> pos <span style=color:#f92672>=</span> 0; pos <span style=color:#f92672>&lt;</span> stemmedTokens.<span style=color:#a6e22e>size</span>(); pos<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            String term <span style=color:#f92672>=</span> stemmedTokens.<span style=color:#a6e22e>get</span>(pos);
</span></span><span style=display:flex><span>            termPositionsInThisBook.<span style=color:#a6e22e>computeIfAbsent</span>(term, k <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>()).<span style=color:#a6e22e>add</span>(pos);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// 4. Add this book&#39;s data to the overall inverted index</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (Map.<span style=color:#a6e22e>Entry</span><span style=color:#f92672>&lt;</span>String, List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;&gt;</span> entry : termPositionsInThisBook.<span style=color:#a6e22e>entrySet</span>()) {
</span></span><span style=display:flex><span>            String term <span style=color:#f92672>=</span> entry.<span style=color:#a6e22e>getKey</span>();
</span></span><span style=display:flex><span>            List<span style=color:#f92672>&lt;</span>Integer<span style=color:#f92672>&gt;</span> positions <span style=color:#f92672>=</span> entry.<span style=color:#a6e22e>getValue</span>();
</span></span><span style=display:flex><span>            <span style=color:#75715e>// A Posting records a book ID, how many times the term appeared (frequency), and its positions</span>
</span></span><span style=display:flex><span>            Posting posting <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Posting(book.<span style=color:#a6e22e>getBookId</span>(), positions.<span style=color:#a6e22e>size</span>(), positions);
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Add this posting to the list for this term in the inverted index</span>
</span></span><span style=display:flex><span>            invertedIndex.<span style=color:#a6e22e>computeIfAbsent</span>(term, k <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>new</span> ArrayList<span style=color:#f92672>&lt;&gt;</span>()).<span style=color:#a6e22e>add</span>(posting);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>indexDocument</code> method is run for each book:</p><ol><li>It collects all descriptive text for the book.</li><li>It uses the <code>textProcessor</code> (our &ldquo;digital editor&rdquo; from <a href=05_text_preprocessing_.md>Text Preprocessing</a>) to clean and standardize the words.</li><li>It then counts how often each word appears in <em>this specific book</em> and notes its positions.</li><li>Finally, it creates a <code>Posting</code> object with this information (<code>bookId</code>, word count, positions) and adds it to the <code>invertedIndex</code> for that specific word.</li></ol><h4 id=4-calculating-word-importance-tfidfcalculator>4. Calculating Word Importance: <code>TfIdfCalculator</code><a hidden class=anchor aria-hidden=true href=#4-calculating-word-importance-tfidfcalculator>#</a></h4><p>After the <code>invertedIndex</code> is built for all books, the <code>TfIdfCalculator</code> then goes through all the words and books to figure out their TF-IDF scores.</p><p><strong><code>src/main/java/utils/TfIdfCalculator.java</code> (Simplified <code>calculateIdf</code> and <code>calculateTfIdf</code> methods)</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>package</span> utils;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> domain.Posting;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> lombok.Getter;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.HashMap;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.List;
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> java.util.Map;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TfIdfCalculator</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Getter</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Map<span style=color:#f92672>&lt;</span>Integer, Map<span style=color:#f92672>&lt;</span>String, Double<span style=color:#f92672>&gt;&gt;</span> tfIdfVectors <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;</span>(); <span style=color:#75715e>// Book ID -&gt; (Word -&gt; TF-IDF Score)</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>@Getter</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> Map<span style=color:#f92672>&lt;</span>String, Double<span style=color:#f92672>&gt;</span> idfScores <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;</span>(); <span style=color:#75715e>// Word -&gt; Overall Rarity Score</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>calculateIdf</span>(Map<span style=color:#f92672>&lt;</span>String, List<span style=color:#f92672>&lt;</span>Posting<span style=color:#f92672>&gt;&gt;</span> invertedIndex, <span style=color:#66d9ef>int</span> totalDocCount) {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Calculating IDF scores for &#34;</span> <span style=color:#f92672>+</span> invertedIndex.<span style=color:#a6e22e>size</span>() <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; terms...&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(String term : invertedIndex.<span style=color:#a6e22e>keySet</span>()) {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// How many documents (books) contain this term</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>int</span> docFrequency <span style=color:#f92672>=</span> invertedIndex.<span style=color:#a6e22e>get</span>(term).<span style=color:#a6e22e>size</span>();
</span></span><span style=display:flex><span>            <span style=color:#75715e>// IDF: The rarer the term (lower docFrequency), the higher its IDF score</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>double</span> idf <span style=color:#f92672>=</span> Math.<span style=color:#a6e22e>log10</span>( (<span style=color:#66d9ef>double</span>) totalDocCount <span style=color:#f92672>/</span> docFrequency );
</span></span><span style=display:flex><span>            idfScores.<span style=color:#a6e22e>put</span>(term, idf); <span style=color:#75715e>// Store overall rarity score for each term</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>calculateTfIdf</span>(Map<span style=color:#f92672>&lt;</span>String, List<span style=color:#f92672>&lt;</span>Posting<span style=color:#f92672>&gt;&gt;</span> invertedIndex) {
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Calculating TF-IDF vectors for all documents...&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span>(String term : invertedIndex.<span style=color:#a6e22e>keySet</span>()) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>double</span> idf <span style=color:#f92672>=</span> idfScores.<span style=color:#a6e22e>get</span>(term); <span style=color:#75715e>// Get the term&#39;s overall rarity score</span>
</span></span><span style=display:flex><span>            List<span style=color:#f92672>&lt;</span>Posting<span style=color:#f92672>&gt;</span> postings <span style=color:#f92672>=</span> invertedIndex.<span style=color:#a6e22e>get</span>(term);
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span>(Posting posting : postings ) {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> docId <span style=color:#f92672>=</span> posting.<span style=color:#a6e22e>getDocId</span>();
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>int</span> termFreq <span style=color:#f92672>=</span> posting.<span style=color:#a6e22e>getFreq</span>(); <span style=color:#75715e>// How many times this term appears in THIS book</span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// TF: More frequent in this book means higher TF</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>double</span> tf <span style=color:#f92672>=</span> 1 <span style=color:#f92672>+</span> Math.<span style=color:#a6e22e>log10</span>(termFreq);
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>double</span> tfIdf <span style=color:#f92672>=</span> tf <span style=color:#f92672>*</span> idf; <span style=color:#75715e>// Combine TF (local importance) and IDF (global rarity)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                <span style=color:#75715e>// Store this word&#39;s TF-IDF score for this specific book</span>
</span></span><span style=display:flex><span>                tfIdfVectors.<span style=color:#a6e22e>computeIfAbsent</span>(docId, k <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>new</span> HashMap<span style=color:#f92672>&lt;&gt;</span>()).<span style=color:#a6e22e>put</span>(term, tfIdf);
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;TF-IDF calculation complete.&#34;</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>calculateIdf</code>: This method first calculates the <strong>Inverse Document Frequency (IDF)</strong> for <em>every unique word</em> across all books. Words that are very common (like &ldquo;programming&rdquo;) will have a low IDF, while unique words will have a high IDF.</li><li><code>calculateTfIdf</code>: Then, for each word in each book, it calculates the <strong>Term Frequency-Inverse Document Frequency (TF-IDF)</strong>. This score combines how often a word appears in a <em>specific book</em> (Term Frequency) with how <em>rare</em> that word is across the <em>entire library</em> (IDF). A high TF-IDF means a word is very important and unique to a document.</li></ul><h3 id=why-offline-search-indexing-is-so-important>Why Offline Search Indexing is So Important<a hidden class=anchor aria-hidden=true href=#why-offline-search-indexing-is-so-important>#</a></h3><p>This pre-computation step might seem like a lot of work, but it&rsquo;s absolutely vital for DevShelf&rsquo;s performance and user experience:</p><table><thead><tr><th style=text-align:left>Feature</th><th style=text-align:left>WITHOUT Offline Search Indexing</th><th style=text-align:left>WITH Offline Search Indexing</th></tr></thead><tbody><tr><td style=text-align:left><strong>Search Speed</strong></td><td style=text-align:left>Very slow, as each query requires re-scanning all books and recalculating scores.</td><td style=text-align:left><strong>Instant!</strong> DevShelf just looks up words and scores in pre-built tables.</td></tr><tr><td style=text-align:left><strong>Efficiency</strong></td><td style=text-align:left>Wastes computer resources by repeating calculations for every search.</td><td style=text-align:left>Calculations done once, data loaded quickly, saving resources during live use.</td></tr><tr><td style=text-align:left><strong>Relevance</strong></td><td style=text-align:left>Harder to accurately rank results without pre-computed word importance scores.</td><td style=text-align:left>Accurate ranking based on scientifically calculated TF-IDF scores.</td></tr><tr><td style=text-align:left><strong>Scalability</strong></td><td style=text-align:left>Slows down dramatically as more books are added.</td><td style=text-align:left>Stays fast even with thousands of books, as the heavy work is done beforehand.</td></tr></tbody></table><h3 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h3><p>In this chapter, we uncovered the essential process of <strong>Offline Search Indexing</strong>. We learned that:</p><ul><li>It&rsquo;s an <strong>offline process</strong> performed by <code>IndexerMain</code> to prepare book data for lightning-fast searches.</li><li>It builds two crucial lookup tables: the <strong>Inverted Index</strong> (mapping words to books) and <strong>TF-IDF scores</strong> (measuring a word&rsquo;s importance to a book and its overall rarity).</li><li>The <code>IndexBuilder</code> meticulously processes each book&rsquo;s text (using our <a href=05_text_preprocessing_.md>Text Preprocessing</a> tools) to populate the inverted index.</li><li>The <code>TfIdfCalculator</code> then assigns numerical importance scores to every word in every book.</li><li>All this prepared data is saved into a file (<code>index_data.json</code>) and efficiently loaded by the <code>IndexLoader</code> when DevShelf starts, turning our digital library into an instant search powerhouse.</li></ul><p>This clever preparation is the foundation upon which DevShelf can provide quick and intelligent search results. Now that DevShelf knows how to find the right books, let&rsquo;s explore how it can make those search results even smarter and more helpful!</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://kas-sim.github.io/tags/java/>Java</a></li><li><a href=https://kas-sim.github.io/tags/algorithms/>Algorithms</a></li><li><a href=https://kas-sim.github.io/tags/system-design/>System Design</a></li></ul><nav class=paginav><a class=prev href=https://kas-sim.github.io/posts/how-search-engines-work/><span class=title>¬´ Prev</span><br><span>The Math Behind the Magic: Vector Space Models in Java</span></a></nav></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://kas-sim.github.io/>Muhammad Qasim</a></span> ¬∑
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>